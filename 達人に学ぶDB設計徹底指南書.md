# 達人に学ぶDB設計徹底指南書
## ３層スキーマ
・外部スキーマ・・・ユーザー視点
・概念スキーマ・・・開発者視点
・内部スキーマ・・・DBMS（データベースマネージメントシステム）
## RAID
RAID0・・・ディスク1（データ1, 3, 5, 7)、ディスク2（データ2, 4, 6, 8)
RAID1・・・ディスク1（データ1, 2, 3, 4)、ディスク2（データ1, 2, 3, 4)
RAID5・・・ディスク1（データA1, B1, D4, パリティC)、ディスク2（データA2, C2, D2, パリティB)、ディスク3（データB2, C2, パリティA, D）
RAID10・・・ディスク1（データ1, 3, 5, 7)、ディスク2（データ1, 3, 5, 7）、ディスク3（データ2, 4, 6, 8)、ディスク4（データ2, 4, 6, 8)
RAID1は安全性高いがパフォーマンス悪い、RAID5はバランスいい
## ファイルの物理配置
・データファイル・・・データ保持
・インデックスファイル
・システムファイル・・・DBMSの内部管理
・一時ファイル・・・DBMS内部の一時的なデータ（サブクエリ展開データ、ソートデータなど）
・ログファイル・・・一旦変更を溜めて、あとでデータファイルへ一括反映。MySQLではバイナリログと呼ばれる。
## インデックス
・B-tree・・・balanced tree（平衡木）。ルートからリーフまでの距離が同じ。O(log n)。否定（<>、!=）は左右分岐判定できないためインデックス効かない。
・カーディナリティ・・・特定のカラムのデータの種類の多さ。
・カーディナリティが高く、なるべく分散していて、検索に使われるカラムにインデックス貼る。
・インデックスは劣化するので、定期的にメンテする（DBMSに専用のコマンドがある）
・主キーや一意キーは既にあるので二重に作成しない
## オプティマイザと実行計画
SQL → パーサ（構文チェック） → オプティマイザ（←→カタログマネージャ←→統計情報） → テーブル
統計情報を更新することで実行計画の精度をあげる
## アンチパターン
・非スカラ値
・ダブルミーニング
・単一参照テーブル・・・テーブルにポリモーフィズムはいらない
・水平分割・・・ストレージのI/Oコスト下げるため、年度ごとにテーブル分けるとか。アプリケーションの変更が必要。
・垂直分割・・・論理的な意味を持たない。集約で代替する（データマート、サマリーテーブル）
・可変長文字列をキー・・・固定長文字列にする
・ダブルマスタ
## sharding
Googleなどの巨大検索エンジンが採用。パーティションは論理的な分離だが、物理的に分離することでI/Oを完全に分離できる。
## グレーノウハウ
・代理キー・・・現実に意味を持たない主キー
・列持ちテーブル・・・子１、子２、子３といったカラム
・アドホックな集計キー
・多段ビュー・・・仮想ビューが何段にも。パフォーマンス低下。
・データクレンジング（名寄せ）
## 木構造
隣接リスト、入れ子集合、入れ子区間、経路列挙
## マテリアライズドビュー
ただのビューは毎回基底のテーブルからSQLを発行して取ってくるのに対し、
マテリアライズドビューは定期的に更新してデータを保持している。
このためパフォーマンス向上ができる。
MySQLにはこの機能が無いので、自前で作る。
## カラムベースデータベース

