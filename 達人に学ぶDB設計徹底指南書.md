# 達人に学ぶDB設計徹底指南書
## ３層スキーマ
・外部スキーマ・・・ユーザー視点<br>
・概念スキーマ・・・開発者視点<br>
・内部スキーマ・・・DBMS（データベースマネージメントシステム）<br>
## RAID
RAID0・・・ディスク1（データ1, 3, 5, 7)、ディスク2（データ2, 4, 6, 8)<br>
RAID1・・・ディスク1（データ1, 2, 3, 4)、ディスク2（データ1, 2, 3, 4)<br>
RAID5・・・ディスク1（データA1, B1, D4, パリティC)、ディスク2（データA2, C2, D2, パリティB)、ディスク3（データB2, C2, パリティA, D）<br>
RAID10・・・ディスク1（データ1, 3, 5, 7)、ディスク2（データ1, 3, 5, 7）、ディスク3（データ2, 4, 6, 8)、ディスク4（データ2, 4, 6, 8)<br>
RAID1は安全性高いがパフォーマンス悪い、RAID5はバランスいい<br>
## ファイルの物理配置
・データファイル・・・データ保持<br>
・インデックスファイル<br>
・システムファイル・・・DBMSの内部管理<br>
・一時ファイル・・・DBMS内部の一時的なデータ（サブクエリ展開データ、ソートデータなど）<br>
・ログファイル・・・一旦変更を溜めて、あとでデータファイルへ一括反映。MySQLではバイナリログと呼ばれる。<br>
## インデックス
・B-tree・・・balanced tree（平衡木）。ルートからリーフまでの距離が同じ。O(log n)。否定（<>、!=）は左右分岐判定できないためインデックス効かない。<br>
・カーディナリティ・・・特定のカラムのデータの種類の多さ。<br>
・カーディナリティが高く、なるべく分散していて、検索に使われるカラムにインデックス貼る。<br>
・インデックスは劣化するので、定期的にメンテする（DBMSに専用のコマンドがある）<br>
・主キーや一意キーは既にあるので二重に作成しない<br>
## オプティマイザと実行計画
SQL → パーサ（構文チェック） → オプティマイザ（←→カタログマネージャ←→統計情報） → テーブル<br>
統計情報を更新することで実行計画の精度をあげる<br>
## アンチパターン
・非スカラ値<br>
・ダブルミーニング<br>
・単一参照テーブル・・・テーブルにポリモーフィズムはいらない<br>
・水平分割・・・ストレージのI/Oコスト下げるため、年度ごとにテーブル分けるとか。アプリケーションの変更が必要。<br>
・垂直分割・・・論理的な意味を持たない。集約で代替する（データマート、サマリーテーブル）<br>
・可変長文字列をキー・・・固定長文字列にする<br>
・ダブルマスタ<br>
## sharding
Googleなどの巨大検索エンジンが採用。パーティションは論理的な分離だが、物理的に分離することでI/Oを完全に分離できる。<br>
## カラムベースデータベース
## グレーノウハウ
・代理キー・・・現実に意味を持たない主キー<br>
・列持ちテーブル・・・子１、子２、子３といったカラム<br>
・アドホックな集計キー<br>
・多段ビュー・・・仮想ビューが何段にも。パフォーマンス低下。<br>
・データクレンジング（名寄せ）<br>
## 木構造
隣接リスト、入れ子集合、入れ子区間、経路列挙<br>
## マテリアライズドビュー
ただのビューは毎回基底のテーブルからSQLを発行して取ってくるのに対し、<br>
マテリアライズドビューは定期的に更新してデータを保持している。<br>
このためパフォーマンス向上ができる。<br>
MySQLにはこの機能が無いので、自前で作る。<br>

